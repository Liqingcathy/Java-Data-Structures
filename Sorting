## Sorings
1. [Bubble Sort](https://www.bilibili.com/video/BV1et411b73Z?p=46)
ex[ ] = {4,2,8,0,5,7,1,3,9} 
- Each element is compared with its adjacent element.
- In each comparison,if ex[i] > ex[i+1], swap the data, until reach the end of the array.
- After each round(loop), the largest element is 'bubbled' at the end of array, so need to compare that one in next round(n-1)
   (The largest data is like a bubble, is bubbled up and put in the proper place when we found it)
- In next round,proceed same comparison, bubble up larger data.
- Each element is sorted in ascending order.
<img width="604" alt="Screen Shot 2021-06-10 at 2 04 36 PM" src="https://user-images.githubusercontent.com/53241017/121596814-d0f74000-c9f4-11eb-91f8-cf2a94d2821e.png">


Big(O) Analysis:
|Worst case|Avg case|Best case| 
|----------|--------|---------|
|   O(N^2)  |  O(N^2) |    O(N)  |

Algorithm:
1. comparision round outer loop: size - 1 (largest data is bubbled up to the rightmost index);
2. comparision inner loop: size - comparision round - 1
 
Java code 
```Java
//outer loop:总共排序轮数 = 元素个数-1
for(int i=0; i < arr.size()-1; i++){ 
  //inner loop:每轮对比次数 = 元素个数 - 排序轮数 - 1
  for(int j=0; j<arr.size()-i-1; j++){  
    //find larger one and swap
    if(arr[j] > arr[j+1]){ 
      swap(arr[j], arr[j+1]);
    }
  }
}
``` 
C++ code
```C++
template <class ItemType>
void bubbleSort(ItemType theArray[], int n){
    bool sorted = false; // False when swaps occur
    int round = 1;
    while (!sorted && (round < n){
        sorted = true; // Assume sorted
        for (int i = 0; i < n - round; i++){
            int nextIndex = i + 1;
            if (theArray[index] > theArray[nextIndex]){
                std::swap(theArray[index], theArray[nextIndex]);
                sorted = false; // Signal exchange
            } 
        } 
        round++;
    } 
} 
```
2. [Selection sort](https://www.geeksforgeeks.org/selection-sort/)
- Sorts an array by repeatedly finding the **<u>minimum element</u>** or **<u>maximum element</u>**
- Put min in the beginning or put max in the end of an array
- The algorithm maintains two subarrays in a given array(sorted and unsorted)

Big(O) Analysis:
|Worst case|Avg case|Best case| 
|----------|--------  |---------|
|   O(N^2)  |   O(N^2)  |   O(N^2)  |

<img width="927" alt="Screen Shot 2021-06-10 at 2 10 32 PM" src="https://user-images.githubusercontent.com/53241017/121597533-aeb1f200-c9f5-11eb-94f8-70b30e863f76.png">

C++ find min
```c++
int main() { 
    int arr[] = {64, 25, 12, 22, 11}; 
    int n = sizeof(arr)/sizeof(arr[0]); 
    selectionSort(arr, n); 
 }
void selectionSort(int arr[], int n) { 
    int i, j, min_idx; 
    // One by one move boundary of unsorted subarray 
    for (i = 0; i < n-1; i++) { 
        // Find the minimum element in unsorted array 
        min_idx = i; 
        for (j = i+1; j < n; j++) 
        if (arr[j] < arr[min_idx]) 
            min_idx = j;   
        // Swap the found minimum element with the first element 
        swap(&arr[min_idx], &arr[i]); 
    } 
} 
```
<img width="450" alt="Screen Shot 2021-06-10 at 2 11 14 PM" src="https://user-images.githubusercontent.com/53241017/121597576-bd000e00-c9f5-11eb-94f7-02454a4c0071.png">

C++ find max
```C++
template <class ItemType>
void selectionSort(ItemType theArray[], int n){
    for (int last = n - 1; last >= 1; last--){
        int largest = findIndexOfLargest(theArray, last+1);
        std::swap(theArray[largest], theArray[last]);
    } 
}  
template <class ItemType>
int findIndexOfLargest(const ItemType theArray[], int size){
    int indexSoFar = 0;
    for (int currentIndex = 1; currentIndex < size; currentIndex++){
        if (theArray[currentIndex] > theArray[indexSoFar])
            indexSoFar = currentIndex;
    }
    return indexSoFar;
}
```
3. [Insertion sort](https://www.bilibili.com/video/BV1AE411A7Zh?from=search&seid=8166057879221556005)
-  The array is virtually split into a sorted and an unsorted part. 
-  Values from the unsorted part are picked and placed at the correct position in the sorted part.
-  The insertion requires shift array entries to make room for the inserted item
-  No need to swap entries every time

<img width="563" alt="Screen Shot 2021-06-10 at 1 06 10 PM" src="https://user-images.githubusercontent.com/53241017/121596395-372f9300-c9f4-11eb-81dd-11f65b2a282d.png">

Big(O) Analysis:
|Worst case|Avg case|Best case| 
|----------|--------|---------|
|   O(N^2)  |   O(N^2)  |   O(N)  |

Note: 
Best case- When inner loop is sorted, exit immediately
Worst case- reversed array

[Algorithm]:(https://www.geeksforgeeks.org/insertion-sort/)
- Store the second element in the unsorted region and insert it into its proper position in the sorted region
- Iterate from arr[1] to arr[n] over the array in the unsorted resion
- Compare the current element to its predecessor(sorted)


C++ code1
```c++
void insertionSort(int array[], int len){
  if(len < 2){
    return 0;
  }
  for(int i = 1; i < len; i++){
    int insertValue = array[i]; //store second value 
    int j = i - 1; //predecessor
    //compare right(unsorted) to left(sorted) element
    for(int j >=0 && insertValue < array[j]; j--){
      array[j+1] = array[j]; //Shift array[j] to the right to make room for insertionValue
    }
    array[j+1] = insertValue; //insert value to sorted region
  }
}
/*
     i
 12, 11, 13, 5, 6
     ins
  j   
 if(i < j)
          i
 11, 12, 13, 5, 6
      j
 ins    
             i
 11, 12, 13, 5, 6
         j  ins
                i
 5, 11, 12, 13, 6  
            j  ins
*/
```
4. [Merge sort](https://mediaplayer.pearsoncmg.com/assets/secs-vn-faster-sorting-algorithms)
- Divide into 2 or more than two sub-problems
- Solve sub-problems recursively until reach base case(subarray has 1 ele)
- Merge sub arrays to formulate overall array

Big(O) Analysis:
|Worst case|Avg case|Best case| 
|----------|--------|---------|
|   O(NlogN)  |   O(NlogN)  |   O(NlogN)  |

Note: disadvantage is taking lots of space(O(n)) slows operations

<img width="685" alt="Screen Shot 2021-06-10 at 2 13 03 PM" src="https://user-images.githubusercontent.com/53241017/121597958-2122d200-c9f6-11eb-8106-8d7d76a4cf4f.png">

Algorithms:
- Find the middle point to divide the array into two halves:  middle m = l + (r-l)/2
- Call mergeSort for first half:  Call mergeSort(arr, l, m)
- Call mergeSort for second half: Call mergeSort(arr, m+1, r)
- Merge the two halves sorted in step 2 and 3: Call merge(arr, l, m, r)
C++ code
```C++
//int arr[] = { 12, 11, 13, 5, 6, 7 };
//int arr_size = sizeof(arr) / sizeof(arr[0]);
//mergeSort(arr, 0, arr_size - 1);  

// l is for left index and r is right index of the sub-arrayof arr to be sorted
template <class ItemType>
void mergeSort(ItemType arr[], int l, int r) {
    if (l < r) {
        // Same as (l+r)/2 but avoids overflow for large l & h
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

// 12, 11, 13,  5,  6,  7
//  0   1   2   3   4   5
//  l       m           r 
void merge(ItemType arr[], int l, int m, int r) {
    int k;
    int n1 = m - l + 1; //size = m - l = 2 -> 2+1 = 3 size
    int n2 = r - m; //size = 3    

    // Create temp arrays
    int* L = new int[n1];
    int* R = new int[n2];

    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    // Merge the temp arrays
    // back into arr[l..r]
    int i = 0;
    int j = 0;
    k = l;

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements
    // of L[], if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements
    // of R[], if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }

    delete[] L;
    delete[] R;
}

```
5. [Quick sort](https://www.geeksforgeeks.org/quick-sort/)
- An **improvement to bubble sort**
- Find the element Pivot which divides the array into 2 halves s1, s2
- Compare element in s1 to Pivot, swap as necessary 
- Recursively quick sort s1, s2 and compare elements with its own Pivot(rightmost)
- Values smaller than the Pivot are **<u>moved directly from the back to the front, thereby reducing the total number of comparisons and the number of mobile exchanges.</u>**

<img width="638" alt="Screen Shot 2021-06-10 at 3 00 02 PM" src="https://user-images.githubusercontent.com/53241017/121603734-15d3a480-c9fe-11eb-9ed0-a081a0d99655.png">


Big(O) Analysis:
|Worst case|Avg case|Best case| 
|----------|--------|---------|
|   O(N^2)  |   O(N^2)  |  O(NlogN) |

Algorithm:
- Parition
- QuickSort(left)
- QuickSort(right)

<img width="1426" alt="Screen Shot 2021-06-10 at 3 22 02 PM" src="https://user-images.githubusercontent.com/53241017/121604733-e6be3280-c9ff-11eb-8330-f2ca89d59937.png">
<img width="1418" alt="Screen Shot 2021-06-10 at 3 22 43 PM" src="https://user-images.githubusercontent.com/53241017/121604746-ec1b7d00-c9ff-11eb-8cf6-1bacd03337f6.png">
<img width="744" alt="Screen Shot 2021-06-10 at 3 24 39 PM" src="https://user-images.githubusercontent.com/53241017/121604780-00f81080-ca00-11eb-9c28-daffb861d477.png">
<img width="679" alt="Screen Shot 2021-06-10 at 3 28 41 PM" src="https://user-images.githubusercontent.com/53241017/121605056-90052880-ca00-11eb-9a13-db2265871b85.png">

C++ code
```c++
const int MIN_SIZE = 3;

/* This function takes last element as pivot, places
   the pivot element at its correct position in sorted
    array, and places all smaller (smaller than pivot)
   to left of pivot and all greater elements to right
   of pivot */
int partition (int arr[], int low, int high){
    int pivot = arr[high]; // pivot
    int i = (low - 1); // Index of smaller element and indicates the right position of pivot found so far
 
    for (int j = low; j <= high - 1; j++){
        // If current element is smaller than the pivot
        if (arr[j] < pivot){
            i++; // increment index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high){
    if (low < high){
        /* pi is partitioning index, arr[p] is now
        at right place */
        int pi = partition(arr, low, high);
 
        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
``
